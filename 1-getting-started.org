* Chapter 1: Khởi đầu

Khi bạn đọc các chương dầu cuốn sách này, hãy luôn nhớ rằng đôi khi
chúng tôi giới thiệu những ý tưởng dưới dạng rất đơn giản và hạn chế.
Haskell là một ngôn ngữ rất sâu sắc, và việc trình bày mọi khía cạnh
của chủ đề cùng một lúc có lẽ là quá sức. Khi đã thiết lập được một
nền tảng vững chắc trong Haskell, chúng tôi sẽ mở rộng thêm dựa trên
những lý giải ban đầu này.

** Môi trường Haskell bạn dùng

Trình biên dịch The Glasgow Haskell Compiler (GHC) là cái được dùng
nhiều nhất. Nó biên dịch thành ngôn ngữ máy, hỗ trợ thực thi song song,
và cung cấp những công cụ gỡ lỗi và phân tích hiệu năng rất hữu ích.

GHC có ba thành phần chính.

- ~ghc~ là một trình biên dịch tối ưu đẻ phát sinh mã ngôn ngữ máy chạy nahnh.
- ~ghci~ là một trình gỡ lỗi và thông dịch tương tác.
- ~runghc~ là một chương trình để chạy các chương trình Haskell khác như thể chúng là các văn lệnh (script),
  mà không cần phải biên dịch chúng trước.

#+BEGIN_NOTE
Cách đề cập tới các thành phần của GHC

Khi chúng thảo luận về toàn hệ thống GHC, chúng tôi sẽ gọi nó là
GHC. Nếu nói về từng lệnh cụ thể, chúng tôi sẽ gọi tên 
~ghc~, ~ghci~, hay ~runghc~.
#+END_NOTE

Trong sách này, chúng tôi coi như bạn đang dùng phiên bản GHC 8.2.2
hoặc mới hơn; phiên bản này phát hành năm 2017. Để nhận được một bản sao của GHC,
hãy đến [[http://www.haskell.org/downloads][trang tải về GHC]], và tìm trong danh sách
các gói nhị phân và trình cài đặt.

Nhiều bản phân phối Linux, và các nhà cung cấp của BSD cũng như các
biến thể Unix khác, đã phát hành các gói nhị phân GHC theo yêu cầu. Vì 
được dựng riêng cho từng môi trường nên chúng dễ cài đặt và sử dụng 
hơn hẳn các gói nhị phân chung sẵn có ở trang  tải về GHC. 
Bạn có thể tìm thấy một danh sách các bản phân phối 
đã có GHC dựng theo yêu cầu tại trang web
[[http://www.haskell.org/ghc/distribution_packages.html][các gói phân phối]] GHC.

Để cung cấp thêm thông tin về cách cài đặt GHC trên một loạt 
những nền tảng thông dụng, chúng tôi đã soạn một số hướng dẫn ở
[[file:installing-ghc-and-haskell-libraries.html][Phụ lục A, /Cài đặt GHC và các thư viện Haskell/]].

** Bắt đầu với trình thông dịch ghci

Trình thông dịch tương tác cho GHC là một chương trình có tên ~ghci~. 
Nó cho phép ta nhập vào và ước lượng các biểu thức Haskell, khám phá các module
và gỡ lỗi mã lệnh bạn viết ra. Nếu bạn đã quen với Python hay Ruby,
~ghci~ có phần giống với ~python~ và ~irb~, các trình thông dịch tương tác
của Python và Ruby.

#+BEGIN_NOTE
Lệnh ~ghci~ có một mục tiêu hẹp 

Thông thường, ta không thể sao chép một đoạn mã từ file nguồn Haskell 
và dán thẳng vào ~ghci~. Điều này không có ý nghĩa đáng kể đối với 
việc gỡ lỗi các đoạn mã lệnh, nhưng ban đầu nó có thể gây ngạc nhiên
nếu bạn đã từng quen với, chẳng hạn trình thông dịch Python.
#+END_NOTE

Trên các hệ thống tựa Unix, ta chạy ~ghci~ như một câu lệnh trong 
cửa sổ dòng lệnh. Trên Windows, có thể truy cập qua Start Menu. 
Chẳng hạn, nếu bạn đã cài đặt bằng bộ cài GHC installer cho Windows,
bạn cần vào "Programs", rồi "GHC"; sau đó bạn sẽ thấy 
~ghci~ trong danh sách. (Xem chụp màn hình 
[[file:installing-ghc-and-haskell-libraries.org::*Windows][mục "Windows"]].)

Khi ta chạy ~ghci~, nó hiện ra một hình báo khởi động, tiếp theo là
một dấu nhắc ~Prelude>~. Ở đây, chúng tôi cho thấy phiên bản 8.2.2.

#+BEGIN_SRC screen
$ ghci
GHCi, version 8.2.2: http://www.haskell.org/ghc/  :? for help
Prelude>
#+END_SRC

Từ ~Prelude~ ở dấu nhắc lệnh cho thấy rằng ~Prelude~, một
thư viện chuẩn giữ các hàm hữu ích, đã được nạp và sẵn sàng sử dụng.
Khi ta nạp các module hoặc file nguồn khác, chúng cũng sẽ hiện lên
trên dấu nhắc lệnh.

#+BEGIN_TIP
Nhận trợ giúp

Nếu bạn gõ vào ~:?~ từ dấu nhắc ~ghci~, nó sẽ in ra một thông điệp
trợ giúp khá dài.
#+END_TIP

Module ~Prelude~ đôi khi được gọi là "đoạn mở đầu chuẩn",
vì nội dung của nó được định nghĩa trong chuẩn Haskell 2010. 
Người ta thường gọi tắt nó là "đoạn mở đầu".

#+BEGIN_NOTE
Về dấu nhắc ghci

Dấu nhắc hiển thị bởi ~ghci~ thường xuyên thay đổi tùy thuộc vào 
những module nào ta đã nạp xong. Nó có thể kéo dài đến nỗi 
chỗ ta nhập dòng lệnh chỉ còn lại ngắn ngủn.

Để cho gọn và thống nhất, trong sách này chúng tôi đã thay các dấu nhắc mặc định
của ~ghci~ với chuỗi dấu nhắc ~ghci>~.

Nếu bạn muốn tự làm điều này, hãy dùng dẫn hướng ~:set prompt~ của ~ghci~ 
như sau.

#+BEGIN_SRC screen
Prelude> :set prompt "ghci> "
ghci>
#+END_SRC
#+END_NOTE

Đoạn mở đầu này luôn ngầm sẵn có; ta không cần phải làm gì thêm 
để dùng các kiểu dữ liệu, giá trị, hay hàm mà nó định nghĩa. Để
dùng các định nghĩa từ những module khác, ta phải nạp chúng vào ~ghci~
bằng lệnh ~:module~.

#+BEGIN_SRC screen
ghci> :module + Data.Ratio
#+END_SRC

Bây giờ ta có thể dùng tính năng của module ~Data.Ratio~ module,
module này cho ta làm việc với các số hữu tỉ (phân số).

** Tương tác cơ bản: dùng ghci làm máy tính tay

Ngoài việc cho ta một giao diện thuận tiện để kiểm thử các đoạn
mã lệnh, ~ghci~ còn có thể hoạt động như một máy tính (bấm) tay
dễ dùng. Trong ~ghci~, ta có thể dễ dàng diễn đạt những phép toán
của máy tính tay, và hơn thế nữa ta còn có thể thêm nhiều 
phép tính phức tạp khi đã quen dần với Haskell. Ngay cả khi dùng
trình thông dịch theo cách đơn giản này cũng có thể giúp ta 
dễ hiểu cách hoạt động của Haskell.

*** Phép toán số đơn giản

Ta có thể lập tức nhập vào các biểu thức, để xem ~ghci~ sẽ làm
những gì với chúng. Các phép toán số học hoạt động tương tự như 
các ngôn ngữ như C và Python: ta viết biểu thức theo dạng 
/trung tố/, trong đó toán tử viết giữa các toán hạng.

#+BEGIN_SRC screen
ghci> 2 + 2
4
ghci> 31337 * 101
3165037
ghci> 7.0 / 2.0
3.5
#+END_SRC

Kiểu trung tố để viết biểu thức chỉ là một sự thuận tiện: ta cũng
có thể viết biểu thức theo dạng /tiền tố/, trong đó toán tử
viết trước các đối số. Muốn làm vậy, ta phải dùng cặp ngoặc tròn
bao quanh toán tử.

#+BEGIN_SRC screen
ghci> 2 + 2
4
ghci> (+) 2 2
4
#+END_SRC

Như các biểu thức trên đã ngụ ý, Haskell hình dung ra được
các số nguyên và số phẩy động. Các số nguyên có thể lớn tùy ý.
Ở đây, ~(^)~ cho phép tính lũy thừa.

#+BEGIN_SRC screen
ghci> 313 ^ 15
27112218957718876716220410905036741257
#+END_SRC

*** Điểm kì quái: viết các số âm

Haskell cho thấy một đặc điểm về cách mà ta phải viết các số:
thường cần dùng cặp ngoặc tròn bao lấy số âm. Điều này có hiệu lực
ngay khi viết các biểu thức chỉ đơn giản ở mức trung bình.

Ta hãy bắt đầu bằng việc viết một số âm.

#+BEGIN_SRC screen
ghci> -3
-3
#+END_SRC

Dấu ~-~ ở trên là toán tử một ngôi. Nói cách khác, ta không viết 
con số "-3"; mà là viết số "3", rồi áp dụng
toán tử ~-~ lên nó. Trong Haskell, toán tử một ngôi duy nhất là ~-~,
và ta không thể trộn nó lẫn với các toán tử trung tố được.

#+BEGIN_SRC screen
ghci> 2 + -3

<interactive>:1:1: error:
    Precedence parsing error
        cannot mix ‘+’ [infixl 6] and prefix `-' [infixl 6] in the same infix expression
#+END_SRC

Nếu muốn dùng toán tử một ngôi này cùng với một toán tử trung tố thì
ta phải lấy cặp ngoặc tròn để bọc quanh biểu thức mà toán tử một ngôi áp dụng.

#+BEGIN_SRC screen
ghci> 2 + (-3)
-1
ghci> 3 + (-(13 * 37))
-478
#+END_SRC

Điêu này sẽ giúp tránh được sự mập mờ khi tách mã (parsing). Khi áp dụng
một hàm trong Haskell, ta viết tên hàm, theo sau là đối số, 
chẳng hạn ~f 3~. Nếu đã không cần lấy ngoặc tròn để bọc số âm thì
sẽ có đến hai cách để hiểu ~f-3~: đó có thể là 
"áp dụng hàm ~f~ cho số ~-3~", hay 
"lấy biến ~f~ trừ đi ~3~".

/Đại đa số/ trường hợp, trong biểu thức ta có thể phớt lờ dấu cách 
(các kí tự "trống" nói chung gồm cả dấu tab), và Haskell sẽ
phân tách biểu thức như ý ta muốn. Song không phải luôn như vậy.
Đây là một biểu thức hoặt động được:

#+BEGIN_SRC screen
ghci> 2*3
6
#+END_SRC

Và đây là một biểu thước dường như giống vấn đề số âm ở ví dụ trên,
nhưng lại xuất hiện thông báo lỗi hoàn toàn khác.

#+BEGIN_SRC screen
ghci> 2*-3

<interactive>:1:1: error:
    • Variable not in scope: (*-) :: Integer -> Integer -> t
    • Perhaps you meant one of these:
        ‘*’ (imported from Prelude), ‘-’ (imported from Prelude),
        ‘*>’ (imported from Prelude)
#+END_SRC

Ở đây, Haskell lại hiểu ~*-~ như một toán tử đơn lẻ.
Haskell cho phép ta định nghĩa toán tử mới (một chủ đề mà 
ta sẽ trở lại sau), nhưng ta chưa định nghĩa ~*-~. Một lần nữa,
ta lại rắc rối với ngoặc tròn và ~ghci~ lại nhìn nhận biểu thức
theo cách này.

#+BEGIN_SRC screen
ghci> 2*(-3)
-6
#+END_SRC

So với những ngôn ngữ khác, cách xử lý số âm một cách bất thường thế này
có vẻ thật khó chịu, nhưng nó cho thấy một sự đánh đổi có lý.
Haskell cho phép ta định nghĩa các toán tử mới mọi lúc. 
Đây không phải đặc điểm ngôn ngữ bí truyền gì; trong những chương tới đây
ta sẽ thấy một vài toán tử do người dùng tự định nghĩa. Nhóm thiết kế
ngôn ngữ chọn chấp nhận một cú pháp hơi dài dòng để viết số nguyên
nhưng đổi lại được năng lực biểu đạt cao.

*** Logic, toán tử, và so sánh các giá trị Boole

Các giá trị logic Boole trong Haskell là ~True~ và ~False~. 
Điều quan trọng là phải viết in các chữ cái đầu. Haskell sử dụng
các toán tử ảnh hưởng từ C để làm việc với các giá trị Boole: ~(&&)~ là
phép "và" logic, còn ~(||)~ là phép "hoặc" logic.

#+BEGIN_SRC screen
ghci> True && False
False
ghci> False || True
True
#+END_SRC

Có những ngôn ngữ lập trình coi số không đồng nghĩa với 
~False~, nhưng Haskell thì không, và cũng không coi
giá trị khác không là ~True~.

#+BEGIN_SRC screen
ghci> True && 1

<interactive>:1:9: error:
    • No instance for (Num Bool) arising from the literal ‘1’
    • In the second argument of ‘(&&)’, namely ‘1’
      In the expression: True && 1
      In an equation for ‘it’: it = True && 1
#+END_SRC

Một lần nữa, ta lại đối mặt với một thông báo lỗi coi vẻ nghiêm trọng.
Nói gọn lại, thông báo này cho ta biết rằng kiểu boole, ~Bool~, 
không thuộc về nhóm kiểu dữ liệu số, ~Num~. Thông báo lỗi này 
khá dài vì ~ghci~ đã chỉ ra vị trí của trực trặc,
và gợi ý ta thực hiện những thay đổi khả dĩ để có thể sửa chữa
vấn đề này.

Sau đây ta hãy mổ xẻ chi tiết thông báo lỗi nêu trên.

- "~No instance for (Num Bool)~" cho ta biết rằng ~ghci~ cố gắng
  coi trị số 1 là thuộc kiểu Bool, nhưng nó không thể.
- "~arising from the literal `1'~" cho thấy rằng chính việc ta sử dụng
  số ~1~ đã gây ra trục trặc này.
- "~In the definition of `it'~" đề cập tới một lối tắt của ~ghci~ mà
  ta sẽ lần theo sau mấy trang sách tới.

#+BEGIN_TIP
Đừng sợ khi đối mặt với các thông báo lỗi

Đến đây chúng tôi cần chỉ ra một điểm quan trọng, và sẽ còn lặp lại
xuyên suốt những phần đầu cuốn sách này. Nếu bạn vướng phải trục trặc
hoặc lời thông báo lỗi mà bạn chưa hiểu, /đừng hoảng sợ/. 
Ở giai đoạn đầu này, những gì bạn cần làm là hình dung được 
để khắc phục sự cố này. Khi đã dần tích lũy kinh nghiệm, bạn sẽ thấy
dễ hiểu hơn những phần của lời thông báo mà thoạt đầu còn có vẻ
bí hiểm.

Mục đích phía sau việc đưa ra bộn bề thông báo lỗi thực chất là 
để giúp ta viết mã lệnh đúng, bằng cách thực hiện gỡ lỗi
"tiền trạm", trước khi ta chạy chương trình. Nếu bạn đã có
kinh nghiệm làm việc với những ngôn ngữ có mức tùy tiện (permissive)
cao hơn, thì cách hoạt động mới này có thể gây sốc.
Hãy kiên nhẫn nhé.
#+END_TIP

Đa số các toán tử so sánh trong Haskell đều giống nhữ cái được dùng 
trong C và nhiều ngôn ngữ ảnh hưởng từ C.

#+BEGIN_SRC screen
ghci> 1 == 1
True
ghci> 2 < 3
True
ghci> 4 >= 3.99
True
#+END_SRC

Có một toán tử khác với cái trong C: toán tử "không bằng". 
Trong C, toán tử này viết là ~!=~. Còn ở Haskell, ta viết ~(/=)~,
thế này khá giống với kí hiệu ≠ trong toán học.

#+BEGIN_SRC screen
ghci> 2 /= 3
True
#+END_SRC

Ngoài ra, trong khi các ngôn ngữ tựa C thường dùng ~!~ cho phủ định logic,
Haskell lại dùng hàm ~not~.

#+BEGIN_SRC screen
ghci> not True
False
#+END_SRC

*** Toán tử: thứ tự ưu tiên và sự kết hợp

Cũng như toán đại số hay các ngôn ngữ lập trình khác có dùng
toán tử trung tố, Haskell cũng có khái niệm ưu tiên toán tử.
Ta có thể dùng ngoặc tròn để viết rõ các cụm biểu thức cần nhóm lại,
và thứ tự ưu tiên sẽ cho phép ta bỏ qua vài dấu ngoặc tròn. Chẳng hạn, 
toán tử nhân có mức ưu tiên cao hơn toán tử cộng, 
bởi vậy Haskell sẽ coi rằng hai biểu thức sau là tương đương.

#+BEGIN_SRC screen
ghci> 1 + (4 * 4)
17
ghci> 1 + 4 * 4
17
#+END_SRC

Haskell đánh số mức độ ưu tiên cho các toán tử, với mức 1 là
mức ưu tiên thấp nhất và 9 ưu tiên cao nhất. Một toán tử có
mức ưu tiên cao hơn thì được áp dụng trước toán tử ưu tiên thấp.
Ta có thể dùng ~ghci~ để điều tra mức ưu tiên của từng toán tử,
bằng lệnh ~:info~.

#+BEGIN_SRC screen
ghci> :info (+)
class (Eq a, Show a) => Num a where
  (+) :: a -> a -> a
  ...
    -- Defined in GHC.Num
infixl 6 +
ghci> :info (*)
class (Eq a, Show a) => Num a where
  ...
  (*) :: a -> a -> a
  ...
    -- Defined in GHC.Num
infixl 7 *
#+END_SRC

Thông tin mà ta cần tìm ở dòng "~infixl 6 +~", vốn
cho thấy rằng toán tử ~(+)~ có mức ưu tiên bằng 6. (Chúng tôi sẽ
giải thích thêm về những thông in khác ở một chương sau này.) 
Còn "~infixl 7 *~" cho ta biết rằng toán tử ~(*)~ có mức ưu tiên 7. Vì
~(*)~ có mức ưu tiên cao hơn ~(+)~, ta thấy vì sao
~1 + 4 * 4~ được ước lượng thành ~1 + (4 * 4)~, chứ không phải ~(1 + 4) * 4~.

Haskell cũng định nghĩa /tính kết hợp/ của các toán tử. Điều này
quy định xem liệu một biểu thức chứa nhiều toán tử cùng loại được
ước lượng từ trái qua phải hay từ phải qua trái. Các toán tử ~(+)~ và
~(*)~ đều kết hợp trái, vốn thể hiện bởi chữ
~infixl~ trong thông tin mà ~ghci~ cho ta ở trên. Một toán tử kết hợp phải
sẽ thể hiện bằng chữ ~infixr~.

#+BEGIN_SRC screen
ghci> :info (^)
(^) :: (Num a, Integral b) => a -> b -> a  -- Defined in GHC.Real
infixr 8 ^
#+END_SRC

Sự kết hợp giữa các quy tắc ưu tiên và kết hợp thường được gọi là 
quy tắc /ấn định/ (fixity).

*** Các giá trị không xác định, và giới thiệu các biến

Đoạn đầu của Haskell, thư viện chuẩn mà ta đã đề cập trước đây, 
đã định nghĩa cho ta ít nhất là một hằng số toán học thông dụng.

#+BEGIN_SRC screen
ghci> pi
3.141592653589793
#+END_SRC

Nhưng ta sẽ sớm thấy rằng thư viện chuẩn này không có đầy đủ các 
hằng số toán học. Hãy tìm số Euler, ~e~, xem sao.

#+BEGIN_SRC screen
ghci> e

<interactive>:1:1: error: Variable not in scope: e
#+END_SRC

Ồ được rồi. Ta phải tự định nghĩa lấy nó.

#+BEGIN_NOTE
Đừng lo khi thấy các thông báo lỗi

Nếu thông báo lỗi "not in scope" (ngoài phạm vi) có vẻ ghê gớm, 
đừng lo lắng. Nó chỉ muốn báo rằng không có biến nào 
được định nghĩa với tên ~e~.
#+END_NOTE

Bằng cách dùng cấu trúc ~let~ trong ~ghci~, ta có thể tự 
định nghĩa tạm thời cho ~e~.

#+BEGIN_SRC screen
ghci> e = exp 1
#+END_SRC

Ở đây ta áp dụng hàm mũ, ~exp~, và cũng là ví dụ đầu tiên
về việc áp dụng hàm trong Haskell. Nếu như các ngôn ngữ
như Python yêu cầu có ngoặc tròn bao quanh các đối số cho
hàm, thì Haskell không cần.

Với ~e~ đã định nghĩa, ta có thể dùng nó cho các biểu thức toán.
Toán tử mũ ~(^)~ mà chúng tôi đã giới thiệu trước đây chỉ có thể 
nâng lên một lũy thừa số nguyên. Để tính với số mũ là một
số phẩy động, ta dùng toán tử mũ ~(**)~.

#+BEGIN_SRC screen
ghci> (e ** pi) - pi
19.99909997918947
#+END_SRC

#+BEGIN_WARNING
Cú pháp này chỉ có riêng trong ghci

Cú pháp ~let~ mà ~ghci~ chấp nhận thì khác với cú pháp
dùng trong "tầng đỉnh" của một chương trình Haskell thông thường.
Ta sẽ thấy cú pháp thông thường ở
[[file:3-defining-types-streamlining-functions.org::*Introducing local variables][mục "Giới thiệu các biến địa phương"]]
#+END_WARNING

*** Xử lý các quy tắc ưu tiên và kết hợp

Đôi khi ta vẫn nên để lại vài cặp ngoặc tròn trong biểu thức, 
dù Haskell có cho phép bỏ qua chúng. Sự có mặt những ngoặc tròn
này có thể giúp độc giả về sau (và cả chúng ta nữa) hiểu được
mã lệnh muốn làm gì.

Quan trọng hơn nữa còn là vì những biểu thức phức tạp mà phụ thuộc
hoàn toàn vào thứ tự ưu tiên toán tử sẽ nhen nhóm nên những lỗi
rất đáng sợ. Hoàn toàn có thể xảy ra trường hợp trình biên dịch 
và con người hình dung khác đi về ý nghĩa của một biểu thức ngắn 
mà không có ngoặc tròn. 

Cũng không cần nhớ hết tất cả quy tắc ưu tiên và kết hợp: nếu bạn
không chắc thì tốt nhất là cứ điền ngoặc tròn vào.


** Biên tập dòng lệnh trong ghci

Ở đa số hệ thống, ~ghci~ có một số khả năng biên tập dòng lệnh.
Nếu bạn chưa quen với việc biên tập dòng lệnh thì những tính năng
này sẽ giúp bạn nhiều thời gian. Những tính năng cơ bản giống nhau 
ở cả các hệ tựa Unix và Windows. Ấn phím ↑ sẽ gọi lại 
câu lệnh gần nhất mà bạn đã nhập vào; ấn phím ↑ liên tiếp sẽ 
duyệt qua các câu lệnh nhập vào trước đây. Bạn có thể dùng các phím 
mũi tên ← và → để di chuyển trong một dòng lệnh. Ở Unix (nhưng không 
may là Windows không làm được), phím ~tab~ sẽ điền nốt những 
tên gọi bạn đang gõ dở.

#+BEGIN_TIP
Tìm thông tin ở đâu?

Ở đây, chúng tôi đã nói qua cách biên tập dòng lệnh. 
Vì bạn có thể làm việc hiệu quả hơn nếu đã quen với 
các tính năng của hệ thống biên tập dòng lệnh, nên có lẽ 
một số tài liệu đọc thêm sẽ hữu ích. ~ghci~ dùng 
thư viện Haskeline làm nền tảng, thư viện này rất [[https://github.com/judah/haskeline/wiki/KeyBindings][mạnh mẽ]] 
và [[https://github.com/judah/haskeline/wiki/UserPreferences][có thể tuỳ chỉnh]].
#+END_TIP

** Danh sách

Một danh sách được bao quanh bởi cặp ngoặc vuông; các phần tử
phân tách bởi dấu phẩy.

#+BEGIN_SRC screen
ghci> [1, 2, 3]
[1,2,3]
#+END_SRC

#+BEGIN_NOTE
Dấu phẩy là dấu phân cách chứ không phải dấu kết thúc

Trong một số ngôn ngữ, phần tử cuối của danh sách có thể kết thúc
bởi một dấu phẩy hay không đều được trước khi đóng ngoặc vuông. Song Haskell
không cho phép điều này. Nếu bạn để lại một dấu phẩy ở cuối (như 
~[1,2,]~), bạn sẽ bị một lỗi phân tách (parse).
#+END_NOTE

Một danh sách có thể dài tuỳ ý. Danh sách rỗng được viết là ~[]~.

#+BEGIN_SRC screen
ghci> []
[]
ghci> ["foo", "bar", "baz", "quux", "fnord", "xyzzy"]
["foo","bar","baz","quux","fnord","xyzzy"]
#+END_SRC

Mọi phần tử trong danh sách đều có cùng kiểu. Ở đây, ta vi phạm 
nguyên tắc này: danh sách của ta bắt đầu bằng hai giá trị Bool values, 
song lại kết thúc bởi một chuỗi.

#+BEGIN_SRC screen
ghci> [True, False, "testing"]

<interactive>:1:15: error:
    • Couldn't match expected type ‘Bool’ with actual type ‘[Char]’
    • In the expression: "testing"
      In the expression: [True, False, "testing"]
      In an equation for ‘it’: it = [True, False, "testing"]
#+END_SRC

Một lần nữa, thông báo lỗi của ~ghci~ rất dài dòng, nhưng nó đơn giản là 
báo cho ta biết rằng không có cách nào chuyển từ chuỗi sang một giá trị Boole
được, nên biểu thức danh sách không thể định kiểu đúng.

Nếu ta viết một dãy các phần tử bằng /kí pháp liệt kê/,
Haskell sẽ tự điền nội dung danh sách cho ta.

#+BEGIN_SRC screen
ghci> [1..10]
[1,2,3,4,5,6,7,8,9,10]
#+END_SRC

Ở đây, các kí tự ~..~ biểu diễn cho /liệt kê/. Ta chỉ có thể dùng
kí pháp này cho những kiểu mà phần tử chúng liệt kê được. Đối với 
các chuỗi kí tự, thì liệt kê như vậy không có ý nghĩa gì, chẳng hạn 
không có cách tổng quát và hợp lý nào để liệt kê ~["foo".."quux"]~.

Nhân thể, hãy lưu ý rằng cách viết khoảng như vậy sẽ cho ta một
/khoảng kín/; danh sách có chứa cả hai phần tử đầu, cuối.

Khi viết một liệt kê, ta có thể tuỳ ý có hoặc không quy định kích thước 
của bước nhảy, bằng cách cung cấp hai phần tử đầu tiên, tiếp theo là 
giá trị để kết thúc dãy liệt kê. 

#+BEGIN_SRC screen
ghci> [1.0,1.25..2.0]
[1.0,1.25,1.5,1.75,2.0]
ghci> [1,4..15]
[1,4,7,10,13]
ghci> [10,9..1]
[10,9,8,7,6,5,4,3,2,1]
#+END_SRC

Ở trường hợp thứ hai nêu trên, danh sách thiếu mất điểm cuối của 
liệt kê, song điều này hợp lý vì nó không phải phần tử thuộc về
danh sách mà ta đã định nghĩa. 

Ta có thể bỏ qua phần tử cuối của một liệt kê. Nếu một kiểu dữ liệu 
không có một "giới hạn trên" tự nhiên, thì việc đó sẽ tạo ra 
vô hạn các giá trị. Chẳng hạn, nếu bạn gõ ~[1..]~ vào dấu nhắc ~ghci~,
thì bạn sẽ phải gián đoạn hoặc huỷ ~ghci~ để ngăn nó khỏi in ra 
một dãy vô hạn các số ngày càng lớn hơn. Nếu bạn thôi thúc muốn 
làm điều này, hãy gõ ~Ctrl-C~ để kết thúc liệt kê. Sau này ta sẽ 
thấy được những danh sách vô hạn như vậy thường hữu ích trong Haskell.

#+BEGIN_WARNING
Hãy cẩn thận với liệt kê các số phẩy động 

Dưới đây là một biểu hiện trái với trực giác ta.

#+BEGIN_SRC screen
ghci> [1.0..1.8]
[1.0,2.0]
#+END_SRC

Phía nội tình, để tránh các vấn đề làm tròn số phẩy động, Haskell thực hiện 
liệt kê từ ~1.0~ đến ~1.8+0.5~.

Việc dùng kí pháp liệt kê với các số phẩy động có thể kéo theo nhiều
bất ngờ, nên nếu bạn buộc phải dùng đến nó, hãy cẩn thận. Biểu hiện 
của dấu phẩy động rất lắt léo trong mọi ngôn ngữ lập trình chứ 
không riêng gì Haskell.
#+END_WARNING

*** Các toán tử trên danh sách

Có hai toán tử thông dụng để làm việc với danh sách. Ta nối 
hai danh sách bằng toán tử ~(++)~.

#+BEGIN_SRC screen
ghci> [3,1,3] ++ [3,7]
[3,1,3,3,7]
ghci> [] ++ [False,True] ++ [True]
[False,True,True]
#+END_SRC

Cơ bản hơn là toán tử ~(:)~, để thêm một phần tử vào 
đầu danh sách. Toán tử này đọc là "cons" (đọc tắt từ
"construct").

#+BEGIN_SRC screen
ghci> 1 : [2,3]
[1,2,3]
ghci> 1 : []
[1]
#+END_SRC

Bạn có thể muốn thử viết ~[1,2] : 3~ để thêm một phần tử vào 
cuối một danh sách, song ~ghci~ sẽ từ chối yêu cầu này với 
thông báo lỗi, vì phần tử đầu tiên của ~(:)~ phải là một phần tử,
còn phần tử thứ hai phải là một danh sách.

** Strings and characters

If you know a language like Perl or C, you'll find Haskell's
notations for strings familiar.

A text string is surrounded by double quotes.

#+BEGIN_SRC screen
ghci> "This is a string."
"This is a string."
#+END_SRC

As in many languages, we can represent hard-to-see characters by
"escaping" them. Haskell's escape characters and escaping rules
follow the widely used conventions established by the C language.
For example, ~'\n'~ denotes a newline character, and ~'\t'~ is a
tab character. For complete details, see
[[file:appendix-characters-strings-and-escaping-rules.org][Appendix B, /Characters, strings, and escaping rules/]].

#+BEGIN_SRC screen
ghci> putStrLn "Here's a newline -->\n<-- See?"
Here's a newline -->
<-- See?
#+END_SRC

Haskell makes a distinction between single characters and text
strings. A single character is enclosed in single quotes.

#+BEGIN_SRC screen
ghci> 'a'
'a'
#+END_SRC

In fact, a text string is simply a list of individual characters.
Here's a painful way to write a short string, which ~ghci~ gives
back to us in a more familiar form.

#+BEGIN_SRC screen
ghci> a = ['l', 'o', 't', 's', ' ', 'o', 'f', ' ', 'w', 'o', 'r', 'k']
ghci> a
"lots of work"
ghci> a == "lots of work"
True
#+END_SRC

The empty string is written ~""~, and is a synonym for ~[]~.

#+BEGIN_SRC screen
ghci> "" == []
True
#+END_SRC

Since a string is a list of characters, we can use the regular
list operators to construct new strings.

#+BEGIN_SRC screen
ghci> 'a':"bc"
"abc"
ghci> "foo" ++ "bar"
"foobar"
#+END_SRC

** First steps with types

While we've talked a little about types already, our interactions
with ~ghci~ have so far been free of much type-related thinking.
We haven't told ~ghci~ what types we've been using, and it's
mostly been willing to accept our input.

Haskell requires type names to start with an uppercase letter, and
variable names must start with a lowercase letter. Bear this in
mind as you read on; it makes it much easier to follow the names.

The first thing we can do to start exploring the world of types is
to get ~ghci~ to tell us more about what it's doing. ~ghci~ has a
command, ~:set~, that lets us change a few of its default
behaviours. We can tell it to print more type information as
follows.

#+BEGIN_SRC screen
ghci> :set +t
ghci> 'c'
'c'
it :: Char
ghci> "foo"
"foo"
it :: [Char]
#+END_SRC

What the ~+t~ does is tell ~ghci~ to print the type of an
expression after the expression. That cryptic ~it~ in the output
can be very useful: it's actually the name of a special variable,
in which ~ghci~ stores the result of the last expression we
evaluated. (This isn't a Haskell language feature; it's specific
to ~ghci~ alone.) Let's break down the meaning of the last line of
~ghci~ output.

- It's telling us about the special variable ~it~.
- We can read text of the form ~x :: y~ as meaning "the
  expression ~x~ has the type ~y~".
- Here, the expression "it" has the type ~[Char]~. (The name
  ~String~ is often used instead of ~[Char]~. It is simply a
  synonym for ~[Char]~.)

#+BEGIN_TIP
The joy of "it"

That ~it~ variable is a handy ~ghci~ shortcut. It lets us use the
result of the expression we just evaluated in a new expression.

#+BEGIN_SRC screen
ghci> "foo"
"foo"
it :: [Char]
ghci> it ++ "bar"
"foobar"
it :: [Char]
#+END_SRC

When evaluating an expression, ~ghci~ won't change the value of
~it~ if the evaluation fails. This lets you write potentially
bogus expressions with something of a safety net.

#+BEGIN_SRC screen
ghci> it
"foobar"
it :: [Char]
ghci> it ++ 3

<interactive>:1:1: error
    • No instance for (Num [Char]) arising from the literal ‘3’
    • In the second argument of ‘(++)’, namely ‘3’
      In the expression: it ++ 3
      In an equation for ‘it’: it = it ++ 3
ghci> it
"foobar"
it :: [Char]
ghci> it ++ "baz"
"foobarbaz"
it :: [Char]
#+END_SRC

When we couple ~it~ with liberal use of the arrow keys to recall
and edit the last expression we typed, we gain a decent way to
experiment interactively: the cost of mistakes is very low. Take
advantage of the opportunity to make cheap, plentiful mistakes
when you're exploring the language!
#+END_TIP

Here are a few more of Haskell's names for types, from expressions
of the sort we've already seen.

#+BEGIN_SRC screen
ghci> 7 ^ 80
40536215597144386832065866109016673800875222251012083746192454448001
it :: Integer
#+END_SRC

Haskell's integer type is named ~Integer~. The size of an
~Integer~ value is bounded only by your system's memory capacity.

Rational numbers don't look quite the same as integers. To
construct a rational number, we use the ~(%)~ operator. The
numerator is on the left, the denominator on the right.

#+BEGIN_SRC screen
ghci> :m +Data.Ratio
ghci> 11 % 29
11%29
it :: Integral a => Ratio a
#+END_SRC

For convenience, ~ghci~ lets us abbreviate many commands, so we
can write ~:m~ instead of ~:module~ to load a module.

Notice /two/ words on the right hand side of the ~::~ above. We
can read this as a "ratio of integer". We might guess that a
~Ratio~ must have values of type Integer as both numerator and
denominator. Sure enough, if we try to construct a ~Ratio~ where
the numerator and denominator are of different types, or of the
same non-integral type, ~ghci~ complains.

#+BEGIN_SRC screen
ghci> 3.14 % 8

<interactive>:1:1: error:
    • Ambiguous type variable ‘a0’ arising from a use of ‘print’
      prevents the constraint ‘(Show a0)’ from being solved.
      Probable fix: use a type annotation to specify what ‘a0’ should be.
      These potential instances exist:
        instance Show a => Show (Ratio a) -- Defined in ‘GHC.Real’
        instance Show Ordering -- Defined in ‘GHC.Show’
        instance Show Integer -- Defined in ‘GHC.Show’
        ...plus 23 others
        ...plus 11 instances involving out-of-scope types
        (use -fprint-potential-instances to see them all)
    • In a stmt of an interactive GHCi command: print it
ghci> 1.2 % 3.4

<interactive>:1:1: error:
    • Ambiguous type variable ‘a0’ arising from a use of ‘print’
      prevents the constraint ‘(Show a0)’ from being solved.
      Probable fix: use a type annotation to specify what ‘a0’ should be.
      These potential instances exist:
        instance Show a => Show (Ratio a) -- Defined in ‘GHC.Real’
        instance Show Ordering -- Defined in ‘GHC.Show’
        instance Show Integer -- Defined in ‘GHC.Show’
        ...plus 23 others
        ...plus 11 instances involving out-of-scope types
        (use -fprint-potential-instances to see them all)
    • In a stmt of an interactive GHCi command: print it
#+END_SRC

Although it is initially useful to have ~:set +t~ giving us type
information for every expression we enter, this is a facility we
will quickly outgrow. After a while, we will often know what type
we expect an expression to have. We can turn off the extra type
information at any time, using the ~:unset~ command.

#+BEGIN_SRC screen
ghci> :unset +t
ghci> 2
2
#+END_SRC

Even with this facility turned off, we can still get that type
information easily when we need it, using another ~ghci~ command.

#+BEGIN_SRC screen
ghci> :type 'a'
'a' :: Char
ghci> "foo"
"foo"
ghci> :type it
it :: [Char]
#+END_SRC

The ~:type~ command will print type information for any expression
we give it (including ~it~, as we see above). It won't actually
evaluate the expression; it only checks its type and prints that.

Why are the types reported for these two expressions different?

#+BEGIN_SRC screen
ghci> 3 + 2
5
ghci> :type it
it :: Integer
ghci> :type 3 + 2
3 + 2 :: (Num t) => t
#+END_SRC

Haskell has several numeric types. For example, a literal number
such as ~1~ could, depending on the context in which it appears,
be an integer or a floating point value. When we force ~ghci~ to
evaluate the expression ~3 + 2~, it has to choose a type so that
it can print the value, and it defaults to ~Integer~. In the
second case, we ask ~ghci~ to print the type of the expression
without actually evaluating it, so it does not have to be so
specific. It answers, in effect, "its type is numeric". We will
see more of this style of type annotation in
[[file:6-using-typeclasses.org][Chapter 6, Using Type Classes]].

** A simple program

Let's take a small leap ahead, and write a small program that
counts the number of lines in its input. Don't expect to
understand this yet; it's just fun to get our hands dirty. In a
text editor, enter the following code into a file, and save it as
~WC.hs~.

#+CAPTION: wc.hs
#+BEGIN_SRC haskell
-- lines beginning with "--" are comments.

main = interact wordCount
    where wordCount input = show (length (lines input)) ++ "\n"
#+END_SRC

Find or create a text file; let's call it ~quux.txt~[fn:1].

#+BEGIN_SRC screen
$ cat quux.txt
Teignmouth, England
Paris, France
Ulm, Germany
Auxerre, France
Brunswick, Germany
Beaumont-en-Auge, France
Ryazan, Russia
#+END_SRC

From a shell or command prompt, run the following command.

#+BEGIN_SRC screen
$ runghc wc < quux.txt
7
#+END_SRC

We have successfully written a simple program that interacts with
the real world! In the chapters that follow, we will successively
fill the gaps in our understanding until we can write programs of
our own.

** Bài tập

1. Enter the following expressions into ~ghci~. What are their
   types?

   - ~5 + 8~
   - ~3 * 5 + 8~
   - ~2 + 4~
   - ~(+) 2 4~
   - ~sqrt 16~
   - ~succ 6~
   - ~succ 7~
   - ~pred 9~
   - ~pred 8~
   - ~sin (pi / 2)~
   - ~truncate pi~
   - ~round 3.5~
   - ~round 3.4~
   - ~floor 3.7~
   - ~ceiling 3.3~

2. From ~ghci~, type ~:?~ to print some help. Define a variable,
   such as ~x = 1~, then type ~:show bindings~. What do you see?
3. The ~words~ function counts the number of words in a string.
   Modify the ~wc.hs~ example to count the number of words in a
   file.
4. Modify the ~wc.hs~ example again, to print the number of
   characters in a file.

** Footnotes

[fn:1] Incidentally, what do these cities have in common?
