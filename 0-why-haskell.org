* Giới thiệu: Tại sao lại là Haskell?

** Chúng tôi có một thứ mới cho bạn!

Haskell là một ngôn ngữ sâu sắc, và chúng tôi nghĩ rằng việc học ngôn ngữ này 
là một trải nghiệm rất đáng giá. Chúng ta sẽ tập trung vào ba yếu tố 
khi giải thích lí do. Thứ nhất là /tính mới/: chúng tôi mời bạn nghĩ về 
lập trình từ một góc nhìn khác đi và rất đáng giá. Thứ hai là 
/năng lực/: chúng tôi sẽ cho bạn thấy cách tạo ra phần mềm ngắn gọn, 
nhanh và an toàn. Cuối cùng, chúng tôi cho bạn nhiều điều /vui vẻ/: 
sự hài lòng khi áp dụng những kĩ thuật lập trình thanh lịch để giải 
những bài toán thực sự.

*** Tính mới

Haskell nhiều khả năng là khác hẳn bất cứ ngôn ngữ nào khác mà bạn 
từng sử dụng trước đây. So với tập hợp khái niệm thông thường trong 
không công cụ tư duy của lập trình viên, lập trình hàm cho ta một 
cách nghĩ khác hẳn về phần mềm.

Trong Haskell, ta bỏ sự nhấn mạnh mã lệnh làm thay đổi dữ liệu. 
Thay vào đó, ta tập trung vào các hàm để nhận vào những giá trị bất biến 
và rồi tạo kết quả đầu ra là những giá trị mới. Miễn là với cùng đầu vào,
các hàm này luôn trả lại kết quả giống nhau. Đây là ý tưởng mấu chốt 
bên trong lập trình hàm.

Cùng với việc không thay đổi dữ liệu, các hàm Haskell của ta thường không 
nói chuyện với thế giới bên ngoài; ta gọi những hàm này là /thuần khiết/.
Chúng ta phân biệt rõ giữa mã lệnh thuần khiết và những phần chương trình 
đọc hoặc ghi file, liên lạc qua kết nối mạng, hoặc làm cử động cánh tay 
robot. Điều này giúp ta tổ chức, luận ra chương trình, và kiểm thử
chương trình dễ dàng hơn.

Chúng tôi bỏ qua một số ý tưởng mà nghe có vẻ cơ bản, như việc có
một vòng lặp ~for~ dựng sẵn trong ngôn ngữ. Chúng ta có những cách khác, 
linh hoạt hơn, để thực hiện việc lặp.

Ngay cả cách mà chúng ta ước lượng các biểu thức cũng khác trong 
Haskell. Chúng ta trì hoãn mọi tính toán cho đến khi kết quả phải
thực sự cần đến: Haskell là ngôn ngữ /lười/. Sự lười biến không phải 
là đùn đẩy công việc qua lại: nó ảnh hưởng sâu sắc đến cách mà ta
viết chương trình.

*** Năng lực

Xuyên suốt cuốn sach này, chúng tôi sẽ cho bạn thấy rằng
so với những ngôn ngữ truyền thống, những cái khác của Haskell
đều rất mạnh mẽ, linh hoạt, và dẫn tói mã lệnh đáng tin cậy. 
Haskell được tích cực nhồi cho những ý tưởng mới mẻ nhất 
về cách tạo nên phần mềm tốt.

Vì mã lệnh thuần khiết không dính líu đến môi trường bên ngoài, và 
dữ liệu mà nó làm việc với thì sẽ không bao giờ thay đổi, nên những
trường hợp ngạc nhiên khó chịu -- kiểu như chẳng hiểu sao mã lệnh lại 
làm rối beng dữ liệu dùng bởi một đoạn mã lệnh khác -- là rất hiếm. 
Bất kể ngữ cảnh nào khi ta dùng một hàm thuần khiết, hàm sẽ luôn ứng xử
một cách nhất quán.

Mã lệnh thuần khiết sẽ dễ kiểm thử hơn là mã lệnh có liên lạc với
môi trường biên ngoài. Khi một hàm chỉ phản hồi với những dữ liệu 
đầu vào hiện hữu, thì ta dễ dàng nêu những thuộc tính với những ứng xử
luôn đúng. Ta có thể tự động kiểm tra rằng những thuộc tính đó luôn đúng 
với một lượng lớn các dữ liệu đầu vào ngẫu nhiên, và khi phép thử đạt 
yêu cầu, ta sẽ tiếp tục. Ta sẽ vẫn dùng những kĩ thuật truyền thống để 
kiểm thử mã lệnh có tương tác với file, mạng hay phần cứng ngoại lai. 
Vì mã lệnh không thuần khiết này sẽ ít gặp so với ở một ngôn ngữ 
truyền thống, nên sẽ đảm bảo hơn là phần mềm sẽ chắc chắn.

Đánh giá lười biếng cũng có vài hiệu ứng đáng sợ. Chẳng hạn, ta muốn 
tìm phần tử nhỏ thứ /k/ trong một danh sách chưa được sắp xếp. 
Với ngôn ngữ truyền thống, cách làm hiển nhiên sẽ là sắp xếp danh sách
này và lấy ra /k/ phần tử đầu, nhưng cách này lại rất tốn kém.
Để hiệu quả hơn, thay vì vậy ta sẽ viết một hàm đặc biệt để nhận 
những giá rị này một lượt, và sẽ phải thực hiện một số thao tác 
kiểm kê khá phức tạp. Trong Haskell, cách sắp xếp rồi lấy 
thực ra sẽ hoạt động tốt: tính lười biếng đảm bảo rằng danh sách 
sẽ chỉ được sắp xếp vừa đủ để tìm thấy phần tử nhỏ /k/ 
xong là thôi.

Còn tốt hơn nữa là mã Haskell vận hành trơn tru cũng rất ngắn gọn 
và chỉ dùng các hàm trong thư viện chuẩn.

#+CAPTION: KMinima.hs
#+BEGIN_SRC haskell
-- lines beginning with "--" are comments.

minima k xs = take k (sort xs)
#+END_SRC

Để dùng trực quan mà hiểu được khi nào cần có việc ước tính theo cách 
lười biếng, có lẽ phải mất chút thời gian. Song khi ta khai thác được
thì mã lệnh thường sẽ ngắn gọn, rõ ràng, và hiệu quả hơn.

Như ví dụ trên đã cho thấy, một khía cạnh quan trọng của sức mạnh Haskell
nằm ở chỗ tính súc tích của mã lệnh được viết ra. So với khi làm việc 
với những ngôn ngữ truyền thống, khi phát triển bằng Haskell ta thường
viết ít mã lệnh hơn hẳn, với thời gian rút ngắn đáng kể và cũng 
ít lỗi hơn.

*** Niềm vui

Chúng tôi tin rằng rất dễ dàng học những thứ cơ bản trong lập trình
Haskell, và bạn sẽ có thể viết thành công những chương trình ngắn 
sau vài giờ hoặc vài ngày học.

Vì việc lập trình hiệu quả bằng Haskell khác hẳn so với những ngôn ngữ
còn lại, nên bạn cần dự trù rằng việc làm chủ cả bản thân
ngôn ngữ này lẫn các kĩ thuật lập trình hàm đều mất rất nhiều 
suy nghĩ và thực hành.

Nhìn lại thời kì trước lúc chúng tôi bắt đầu với Haskell, một tin vui
là sự hứng khởi bắt đầu rất sớm: đơn giản đó chỉ là một thử thách 
hấp dẫn để tìm hiểu sâu về một ngôn ngữ, trong đó 
nhiều ý tưởng thông dụng đã khác đi hoặc còn thiếu, và để hình dung
ra cách viết một chương trình đơn giản.

Đối với chúng tôi, niềm vui ban đâu vẫn còn khi kinh nghiệm dần 
nâng cao và hiểu biêt sâu hơn. Trong những ngôn ngữ khác, thật khó 
tìm được những kết nối giữa khoa học lẫn những sự vụ trong lập trình. 
Trong Haskell, ta đã thu nhập vài ý tưởng từ toán học trừu tượng
và áp dụng vào công việc. Thậm chí, ta còn thấy rằng những ý tưởng
này không chỉ dễ học mà chúng còn phát huy tác dụng để giúp ta
viết được mã lệnh gọn gàng và dễ tái sử dụng hơn.

Ngoài ra, chúng tôi sẽ không dựng nên những "bước tường" chắn đường bạn:
không có khó khăn đặc biệt hay kĩ thuật hiểm hóc nào trong cuốn sách này
mà bạn cần phải làm chủ để có thể lập trình một cách
hiệu quả.

Dù nói vậy, Haskell là một ngôn ngữ nghiêm ngặt: sẽ mất thêm chút 
thời gian để gỡ lỗi phần nhiều mã lệnh trước khi chạy được nó, để
phản hồi cho trình biên dịch báo rằng có chỗ nào trong chương trình
của bạn vô lí hay không. Ngay cả khi đã có nhiều năm kinh nghiệm, 
chúng tôi vẫn ngạc nhiên và hài lòng về mức độ thường xuyên mà
chương trình Haskell chạy được ngay lần thử đầu tiên, một khi 
chúng tôi sửa được những lỗi biên dịch đó.

** Bạn sẽ trông chờ gì ở cuốn sách này 

Chúng tôi khởi đầu dự án này vì ngày càng có nhiều người sử dụng
Haskell để giải quyết các bài toán thường ngày. Vì Haskell có 
nguồn gốc từ giới học thuật nên một số sách Haskell hiện phát hành 
lại tập trung vào những bài toán và kĩ thuật lập trình thường ngày
mà ta quan tâm.

Với cuốn sách này, chúng tôi muốn cho bạn thấy cách dùng lập trình hàm
và Haskell để giải các bài toán thực tế. Đây là một cuốn sách
thực hành: mỗi chương đều có hàng tá mã lệnh ví dụ, và có chương
chứa cả trình ứng dụng hoàn chỉnh. Sau đây là vài ví dụ các 
thư viện, kĩ thuật và công cụ mà chúng tôi sẽ cho bạn thấy cách
xây dựng.

- Tạo một ứng dụng để tải về các kì phát podcast từ
  Internet, và lưu lịch sử tải về vào trong một cơ sở dữ liệu SQL.
- Kiểm thử mã lệnh bạn viết theo cách trực quan mạnh mẽ. Mô tả
  những thuộc tính cần phải giữ đúng, rồi dùng thư viện QuickCheck
  để tự động phát sinh những kịch bản kiểm thử.
- Chụp một tấm ảnh nhòe của hàng mã vạch, và biến nó thành 
  chứng nhận mà bạn có thể dùng để tìm kiếm trong một thư viện
  hoặc trên web site của một hiệu sách.
- Viết mã lệnh sinh sôi nảy nở trên web. Trao đổi dữ liệu với 
  các máy chủ và máy khách được viết bằng những ngôn ngữ khác 
  thông quá kí hiệu JSON. Xây dựng một bộ kiểm tra link tương tranh.

*** Về phía bạn

Bạn cần biết gì trước khi đọc cuốn sách này? Chúng tôi dự trù rằng
bạn đã biết cách lập trình rồi, nhưng nếu bạn chưa từng dùng một
ngôn ngữ lập trình hàm thì cũng được.

Bất kể trình độ kinh nghiệm của bạn, chúng tôi đã cố gắng 
lường trước nhu cầu của bạn: chúng tôi bước xuống và giải thích kĩ
những ý tưởng mới và có thể là các mẹo, thường dùng các ví dụ
và hình ảnh để nhấn mạnh những điểm này.

Là người lập trình mới với Haskell, bạn sẽ không thể tránh khỏi 
việc tự tay viết vài đoạn mã mà đáng lẽ bạn đã dùng một thư viện
hoặc một kĩ thuật lập trình nếu bạn đã biết trước. Chúng tôi đưa vào
cuốn sách này nhiều thông tin để giúp bạn đạt tốc độ 
càng nhanh càng tốt.

Dĩ nhiên, sẽ vẫn có những đoạn gập ghềnh trên con đường ta đi. Nếu bạn
bắt đầu lường trước những ngạc nhiên hoặc khó khăn đôi lúc xảy ra
bệnh cạnh phần thú vị, thì đó chính là trải nghiệm tốt nhất. Bất kì
chỗ gập ghềnh nào bạn va váp sẽ không xảy ra quá lâu.

Khi bạn đã thạo lập trình Haskell hơn, cách viết mã lệnh của bạn
sẽ thay đổi. Thật ra, trong sách này, chúng tôi sẽ trình bày mã lệnh
theo cách tiến hóa dần, cùng với việc chúng ta chuyển dần từ phần
cơ bản của ngôn ngữ lên đến những đặc điểm và kĩ thuật lập trình 
mạnh mẽ hơn và cho kết quả tốt hơn.

** Điều bạn trông chờ từ Haskell

Haskell là một ngôn ngữ lập trình đa mục đích. Nó được thiết kế 
mà không nhằm bất kì một phân khúc ứng dụng nào. Dù rằng Haskell 
giữ vững lập trường về cách viết một chương trình, song nó không
đề cao một lĩnh vực cụ thể nào cả.

Dù tại gốc rễ của nó, Haskell khuyến khích lập trình hàm với 
phong cách thuần khiết và "lười biếng", nhưng đó chỉ là 
/mặc định/, chứ không phải lựa chọn duy nhất. Haskell cũng
trợ giúp những mô hình truyền thống hơn, với mã lệnh thủ tục và
ước lượng chặt chẽ. Hơn nữa, mặc dù mục tiêu của ngôn ngữ
đơn thuần là viết những chương trình định kiểu tĩnh, song cũng
có thể (dù ít gặp) viết mã lệnh Haskell theo lối định kiểu động.


*** So sánh với những ngôn ngữ tĩnh truyền thống

Languages that use simple static type systems have been the
mainstay of the programming world for decades. Haskell is
statically typed, but its notion of what types are for, and what
we can do with them, is much more flexible and powerful than
traditional languages. Types make a major contribution to the
brevity, clarity, and efficiency of Haskell programs.

Although powerful, Haskell's type system is often also
unobtrusive. If we omit explicit type information, a Haskell
compiler will automatically infer the type of an expression or
function. Compared to traditional static languages, to which we
must spoon-feed large amounts of type information, the combination
of power and inference in Haskell's type system significantly
reduces the clutter and redundancy of our code.

Several of Haskell's other features combine to further increase
the amount of work we can fit into a screenful of text. This
brings improvements in development time and agility: we can create
reliable code quickly, and easily refactor it in response to
changing requirements.

Sometimes, Haskell programs may run more slowly than similar
programs written in C or C++. For most of the code we write,
Haskell's large advantages in productivity and reliability
outweigh any small performance disadvantage.

Multicore processors are now ubiquitous, but they remain
notoriously difficult to program using traditional techniques.
Haskell provides unique technologies to make multicore programming
more tractable. It supports parallel programming, software
transactional memory for reliable concurrency, and scales to
hundreds of thousands of concurrent threads.

*** So sánh với các ngôn ngữ động hiện đại

Over the past decade, dynamically typed, interpreted languages
have become increasingly popular. They offer substantial benefits
in developer productivity. Although this often comes at the cost
of a huge performance hit, for many programming tasks productivity
trumps performance, or performance isn't a significant factor in
any case.

Brevity is one area in which Haskell and dynamically typed
languages perform similarly: in each case, we write much less code
to solve a problem than in a traditional language. Programs are
often around the same size in dynamically typed languages and
Haskell.

When we consider runtime performance, Haskell almost always has a
huge advantage. Code compiled by the Glasgow Haskell Compiler
(GHC) is typically between 20 and 60 times faster than code run
through a dynamic language's interpreter. GHC also provides an
interpreter, so you can run scripts without compiling them.

Another big difference between dynamically typed languages and
Haskell lies in their philosophies around types. A major reason
for the popularity of dynamically typed languages is that only
rarely do we need to explicitly mention types. Through automatic
type inference, Haskell offers the same advantage.

Beyond this surface similarity, the differences run deep. In a
dynamically typed language, we can create constructs that are
difficult to express in a statically typed language. However, the
same is true in reverse: with a type system as powerful as
Haskell's, we can structure a program in a way that would be
unmanageable or infeasible in a dynamically typed language.

It's important to recognise that each of these approaches involves
tradeoffs. Very briefly put, the Haskell perspective emphasises
safety, while the dynamically typed outlook favours flexibility.
If someone had already discovered one way of thinking about types
that was always best, we imagine that everyone would know about it
by now.

Of course, we have our own opinions about which tradeoffs are more
beneficial. Two of us have years of experience programming in
dynamically typed languages. We love working with them; we still
use them every day; but usually, we prefer Haskell.

*** Haskell trong công nghiệp và mã nguồn mở

Here are just a few examples of large software systems that have
been created in Haskell. Some of these are open source, while
others are proprietary products.

- ASIC and FPGA design software (Lava, products from Bluespec
  Inc.)
- Music composition software (Haskore)
- Compilers and compiler-related tools (most notably GHC)
- Distributed revision control (Darcs)
- Web middleware (HAppS, products from Galois Inc.)

is a sample of some of the companies using Haskell in late 2008,
taken from the [[http://www.haskell.org/haskellwiki/Haskell_in_industry][Haskell wiki]].

- ABN AMRO is an international bank. It uses Haskell in investment
  banking, to measure the counterparty risk on portfolios of
  financial derivatives.
- Anygma is a startup company. It develops multimedia content
  creation tools using Haskell.
- Amgen is a biotech company. It creates mathematical models and
  other complex applications in Haskell.
- Bluespec is an ASIC and FPGA design software vendor. Its
  products are developed in Haskell, and the chip design languages
  that its products provide are influenced by Haskell.
- Eaton uses Haskell for the design and verification of hydraulic
  hybrid vehicle systems.

*** Biên dịch, gỡ lỗi, và phân tích hiệu năng

For practical work, almost as important as a language itself is
the ecosystem of libraries and tools around it. Haskell has a
strong showing in this area.

The most widely used compiler, GHC, has been actively developed
for over 15 years, and provides a mature and stable set of
features.

- Compiles to efficient native code on all major modern operating
  systems and CPU architectures
- Easy deployment of compiled binaries, unencumbered by licensing
  restrictions
- Code coverage analysis
- Detailed profiling of performance and memory usage
- Thorough documentation
- Massively scalable support for concurrent and multicore
  programming
- Interactive interpreter and debugger

*** Những thư viện đi kèm và từ bên thứ ba

The GHC compiler ships with a collection of useful libraries. Here
are a few of the common programming needs that these libraries
address.

- File I/O, and filesystem traversal and manipulation
- Network client and server programming
- Regular expressions and parsing
- Concurrent programming
- Automated testing
- Sound and graphics

The Hackage package database is the Haskell community's collection
of open source libraries and applications. Most libraries
published on Hackage are licensed under liberal terms that permit
both commercial and open source use. Some of the areas covered by
open source libraries include the following.

- Interfaces to all major open source and commercial databases
- XML, HTML, and XQuery processing
- Network and web client and server development
- Desktop GUIs, including cross-platform toolkits
- Support for Unicode and other text encodings

** Đôi nét về lịch sử Haskell

The development of Haskell is rooted in mathematics and computer
science research.

*** Thời tiền sử

A few decades before modern computers were invented, the
mathematician Alonzo Church developed a language called the lambda
calculus. He intended it as a tool for investigating the
foundations of mathematics. The first person to realize the
practical connection between programming and the lambda calculus
was John McCarthy, who created Lisp in 1958.

During the 1960s, computer scientists began to recognise and study
the importance of the lambda calculus. Peter Landin and
Christopher Strachey developed ideas about the foundations of
programming languages: how to reason about what they do
(operational semantics) and how to understand what they mean
(denotational semantics).

In the early 1970s, Robin Milner created a more rigorous
functional programming language named ML. While ML was developed
to help with automated proofs of mathematical theorems, it gained
a following for more general computing tasks.

The 1970s saw the emergence of lazy evaluation as a novel
strategy. David Turner developed SASL and KRC, while Rod Burstall
and John Darlington developed NPL and Hope. NPL, KRC and ML
influenced the development of several more languages in the 1980s,
including Lazy ML, Clean, and Miranda.

*** Early antiquity

By the late 1980s, the efforts of researchers working on lazy
functional languages were scattered across more than a dozen
languages. Concerned by this diffusion of effort, a number of
researchers decided to form a committee to design a common
language. After three years of work, the committee published the
Haskell 1.0 specification in 1990. It named the language after
Haskell Curry, an influential logician.

Many people are rightfully suspicious of "design by committee",
but the work of the Haskell committee is a beautiful example of
the best work a committee can do. They produced an elegant,
considered language design, and succeeded in unifying the
fractured efforts of their research community. Of the thicket of
lazy functional languages that existed in 1990, only Haskell is
still actively used.

Since its publication in 1990, the Haskell language standard has
seen several revisions, most recently in 2010. A number of Haskell
implementations have been written, and several are still actively
developed.

During the 1990s, Haskell served two main purposes. On one side,
it gave language researchers a stable language in which to
experiment with making lazy functional programs run efficiently.
Other researchers explored how to construct programs using lazy
functional techniques. Still others used it as a teaching
language.

*** Thời kì hiện đại

While these basic explorations of the 1990s proceeded, Haskell
remained firmly an academic affair. The informal slogan of those
inside the community was to "avoid success at all costs". Few
outsiders had heard of the language at all. Indeed, functional
programming as a field was quite obscure.

During this time, the mainstream programming world experimented
with relatively small tweaks: from programming in C, to C++, to
Java. Meanwhile, on the fringes, programmers were beginning to
tinker with new, more dynamic languages. Guido van Rossum designed
Python; Larry Wall created Perl; and Yukihiro Matsumoto developed
Ruby.

As these newer languages began to seep into wider use, they spread
some crucial ideas. The first was that programmers are not merely
capable of working in expressive languages; in fact, they
flourish. The second was in part a byproduct of the rapid growth
in raw computing power of that era: it's often smart to sacrifice
some execution performance in exchange for a big increase in
programmer productivity. Finally, several of these languages
borrowed from functional programming.

Over the past half a decade, Haskell has successfully escaped from
academia, buoyed in part by the visibility of Python, Ruby, and
even Javascript. The language now has a vibrant and fast-growing
culture of open source and commercial users, and researchers
continue to use it to push the boundaries of performance and
expressiveness.

** Những tài liệu hữu ích

As you work with Haskell, you're sure to have questions and want
more information about things. Here are some Internet resources
where you can look up information and interact with other Haskell
programmers.

*** Tài liệu tham khảo

- [[http://www.haskell.org/ghc/docs/latest/html/libraries/index.html][The Haskell Hierarchical Libraries reference]] provides the
  documentation for the standard library that comes with your
  compiler. This is one of the most valuable online assets for
  Haskell programmers.
- For questions about language syntax and features, the
  [[http://haskell.org/onlinereport/haskell2010/][Haskell 2010 Report]] describes the Haskell 2010 language
  standard.
- Various extensions to the language have become commonplace since
  the Haskell 2010 Report was released. The [[http://www.haskell.org/ghc/docs/latest/html/users_guide/index.html][GHC Users's Guide]]
  contains detailed documentation on the extensions supported by
  GHC, as well as some GHC-specific features.
- [[http://haskell.org/hoogle/][Hoogle]] and [[http://holumbus.fh-wedel.de/hayoo/hayoo.html][Hayoo]] are Haskell API search engines. They can search
  for functions by name or by type.

*** Các ứng dụng và thư viện

If you're looking for a Haskell library to use for a particular
task, or an application written in Haskell, check out the
following resources.

- The Haskell community maintains a central repository of open
  source Haskell libraries and applications. It's called
  [[http://hackage.haskell.org/][Hackage]], and it lets you search for software to download, or
  browse its collection by category.
- The [[http://haskell.org/haskellwiki/Applications_and_libraries][Haskell Wiki]] contains a section dedicated to information
  about particular Haskell libraries.

*** Cộng đồng Haskell

There are a number of ways you can get in touch with other Haskell
programmers, to ask questions, learn what other people are talking
about, and simply do some social networking with your peers.

- The first stop on your search for community resources should be
  the [[http://www.haskell.org/][Haskell web site]]. This page contains the most current links
  to various communities and information, as well as a huge and
  actively maintained wiki.
- Haskellers use a number of [[http://haskell.org/haskellwiki/Mailing_lists][mailing lists]] for topical
  discussions. Of these, the most generally interesting is named
  haskell-cafe. It has a relaxed, friendly atmosphere, where
  professionals and academics rub shoulders with casual hackers
  and beginners.
- For real-time chat, the [[http://haskell.org/haskellwiki/IRC_channel][Haskell IRC channel]], named #haskell, is
  large and lively. Like haskell-cafe the atmosphere stays
  friendly and helpful in spite of the huge number of concurrent
  users.
- There are many local user groups, meetups, academic workshops,
  and the like; here is
  [[http://haskell.org/haskellwiki/User_groups][a list of the known user groups and workshops]].
- The [[https://wiki.haskell.org/Haskell_Communities_and_Activities_Report][Haskell Communities and Activities Report]] collects
  information about people that use Haskell, and what they are
  doing with it. It has been running for years, so it provides a
  good way to peer into Haskell's past.

** Lời cảm tạ

This book would not exist without the Haskell community: an
anarchic, hopeful cabal of artists, theoreticians and engineers,
who for twenty years have worked to create a better, bug-free
programming world. The people of the Haskell community are unique
in their combination of friendliness and intellectual depth.

We wish to thank our editor, Mike Loukides, and the production
team at O'Reilly for all of their advice and assistance.

*** Bryan

I had a great deal of fun working with John and Don. Their
independence, good nature, and formidable talent made the writing
process remarkably smooth.

Simon Peyton Jones took a chance on a college student who emailed
him out of the blue in early 1994. Interning for him over that
summer remains a highlight of my professional life. With his
generosity, boundless energy, and drive to collaborate, he
inspires the whole Haskell community.

My children, Cian and Ruairi, always stood ready to help me to
unwind with wonderful, madcap little-boy games.

Finally, of course, I owe a great debt to my wife, Shannon, for
her love, wisdom, and support during the long gestation of this
book.

*** John

I am so glad to be able to work with Bryan and Don on this
project. The depth of their Haskell knowledge and experience is
amazing. I enjoyed finally being able to have the three of us sit
down in the same room -- over a year after we started writing.

My 2-year-old Jacob, who decided that it would be fun to use a
keyboard too, and is always eager to have me take a break from the
computer and help him make some fun typing noises on a 50-year-old
Underwood typewriter.

Most importantly, I wouldn't have ever been involved in this
project without the love, support, and encouragement from my wife,
Terah.

*** Don

Before all else, I'd like to thank my amazing co-conspirators,
John and Bryan, for encouragment, advice and motivation.

My colleagues at Galois, Inc., who daily wield Haskell in the real
world, provided regular feedback and war stories, and helped
ensured a steady supply of espresso.

My PhD supervisor, Manuel Chakravarty, and the PLS research group,
who provided encouragement, vision and energy, and showed me that
a rigorous, foundational approach to programming can make the
impossible happen.

And, finally, thanks to Suzie, for her insight, patience and love.

*** Cảm ơn những người phản biện

We developed this book in the open, posting drafts of chapters to
our web site as we completed them. Readers then submitted feedback
using a web application that we developed. By the time we finished
writing the book, about 800 people had submitted over 7,500
comments, an astounding figure.

We deeply appreciate the time that so many people volunteered to
help us to improve our book. Their encouragement and enthusiasm
over the 15 months we spent writing made the process a pleasure.

The breadth and depth of the comments we received have profoundly
improved the quality of this book. Nevertheless, all errors and
omissions are, of course, ours.

The following people each contributed over 1% of the total number
of review comments that we received. We would like to thank them
for their care in providing us with so much detailed feedback.

Alex Stangl, Andrew Bromage, Brent Yorgey, Bruce Turner, Calvin
Smith, David Teller, Henry Lenzi, Jay Scott, John Dorsey, Justin
Dressel, Lauri Pesonen, Lennart Augustsson, Luc Duponcheel, Matt
Hellige, Michael T. Richter, Peter McLain, Rob deFriesse, Rüdiger
Hanke, Tim Chevalier, Tim Stewart, William N. Halchin.

We are also grateful to the people below, each of whom contributed
at least 0.2% of all comments.

Achim Schneider, Adam Jones, Alexander Semenov, Andrew Wagner,
Arnar Birgisson, Arthur van Leeuwen, Bartek Ćwikłowski, Bas Kok,
Ben Franksen, Björn Buckwalter, Brian Brunswick, Bryn Keller,
Chris Holliday, Chris Smith, Dan Scott, Dan Weston, Daniel
Larsson, Davide Marchignoli, Derek Elkins, Dirk Ullrich, Doug
Kirk, Douglas Silas, Emmanuel Delaborde, Eric Lavigne, Erik
Haugen, Erik Jones, Fred Ross, Geoff King, George Moschovitis,
Hans van Thiel, Ionuț Arțăriși, Isaac Dupree, Isaac Freeman, Jared
Updike, Joe Thornber, Joeri van Eekelen, Joey Hess, Johan Tibell,
John Lenz, Josef Svenningsson, Joseph Garvin, Josh Szepietowski,
Justin Bailey, Kai Gellien, Kevin Watters, Konrad Hinsen, Lally
Singh, Lee Duhem, Luke Palmer, Magnus Therning, Marc DeRosa,
Marcus Eskilsson, Mark Lee Smith, Matthew Danish, Matthew Manela,
Michael Vanier, Mike Brauwerman, Neil Mitchell, Nick Seow, Pat
Rondon, Raynor Vliegendhart, Richard Smith, Runar Bjarnason, Ryan
W. Porter, Salvatore Insalaco, Sean Brewer, Sebastian Sylvan,
Sebastien Bocq, Sengan Baring-Gould, Serge Le Huitouze, Shahbaz
Chaudhary, Shawn M Moore, Tom Tschetter, Valery V. Vorotyntsev,
Will Newton, Wolfgang Meyer, Wouter Swierstra.

We would like to acknowledge the following people, many of whom
submitted a number of comments.

Aaron Hall, Abhishek Dasgupta, Adam Copp, Adam Langley, Adam
Warrington, Adam Winiecki, Aditya Mahajan, Adolfo Builes, Al
Hoang, Alan Hawkins, Albert Brown, Alec Berryman, Alejandro
Dubrovsky, Alex Hirzel, Alex Rudnick, Alex Young, Alexander
Battisti, Alexander Macdonald, Alexander Strange, Alf Richter,
Alistair Bayley, Allan Clark, Allan Erskine, Allen Gooch, Andre
Nathan, Andreas Bernstein, Andreas Schropp, Andrei Formiga, Andrew
Butterfield, Andrew Calleja, Andrew Rimes, Andrew The, Andy
Carson, Andy Payne, Angelos Sphyris, Ankur Sethi, António Pedro
Cunha, Anthony Moralez, Antoine Hersen, Antoine Latter, Antoine
S., Antonio Cangiano, Antonio Piccolboni, Antonios Antoniadis,
Antonis Antoniadis, Aristotle Pagaltzis, Arjen van Schie, Artyom
Shalkhakov, Ash Logan, Austin Seipp, Avik Das, Avinash Meetoo, BVK
Chaitanya, Babu Srinivasan, Barry Gaunt, Bas van Dijk, Ben
Burdette, Ben Ellis, Ben Moseley, Ben Sinclair, Benedikt Huber,
Benjamin Terry, Benoit Jauvin-Girard, Bernie Pope, Björn Edström,
Bob Holness, Bobby Moretti, Boyd Adamson, Brad Ediger, Bradley
Unterrheiner, Brendan J. Overdiep, Brendan Macmillan, Brett
Morgan, Brian Bloniarz, Brian Lewis, Brian Palmer, Brice Lin, C
Russell, Cale Gibbard, Carlos Aya, Chad Scherrer, Chaddaï Fouché,
Chance Coble, Charles Krohn, Charlie Paucard, Chen Yufei, Cheng
Wei, Chip Grandits, Chris Ball, Chris Brew, Chris Czub, Chris
Gallagher, Chris Jenkins, Chris Kuklewicz, Chris Wright, Christian
Lasarczyk, Christian Vest Hansen, Christophe Poucet, Chung-chieh
Shan, Conal Elliott, Conor McBride, Conrad Parker, Cosmo Kastemaa,
Creighton Hogg, Crutcher Dunnavant, Curtis Warren, D Hardman,
Dafydd Harries, Dale Jordan, Dan Doel, Dan Dyer, Dan Grover, Dan
Orias, Dan Schmidt, Dan Zwell, Daniel Chicayban Bastos, Daniel
Karch, Daniel Lyons, Daniel Patterson, Daniel Wagner, Daniil
Elovkov, Danny Yoo, Darren Mutz, Darrin Thompson, Dave Bayer, Dave
Hinton, Dave Leimbach, Dave Peterson, Dave Ward, David Altenburg,
David B. Wildgoose, David Carter, David Einstein, David Ellis,
David Fox, David Frey, David Goodlad, David Mathers, David
McBride, David Sabel, Dean Pucsek, Denis Bueno, Denis Volk, Devin
Mullins, Diego Moya, Dino Morelli, Dirk Markert, Dmitry Astapov,
Dougal Stanton, Dr Bean, Drew Smathers, Duane Johnson, Durward
McDonell, E. Jones, Edwin DeNicholas, Emre Sevinc, Eric Aguiar,
Eric Frey, Eric Kidd, Eric Kow, Eric Schwartz, Erik Hesselink,
Erling Alf, Eruc Frey, Eugene Grigoriev, Eugene Kirpichov, Evan
Farrer, Evan Klitzke, Evan Martin, Fawzi Mohamed, Filippo
Tampieri, Florent Becker, Frank Berthold, Fred Rotbart, Frederick
Ross, Friedrich Dominicus, Gal Amram, Ganesh Sittampalam, Gen
Zhang, Geoffrey King, George Bunyan, George Rogers, German Vidal,
Gilson Silveira, Gleb Alexeyev, Glenn Ehrlich, Graham Fawcett,
Graham Lowe, Greg Bacon, Greg Chrystall, Greg Steuck, Grzegorz
Chrupała, Guillaume Marceau, Haggai Eran, Harald Armin Massa,
Henning Hasemann, Henry Laxen, Hitesh Jasani, Howard B. Golden,
Ilmari Vacklin, Imam Tashdid ul Alam, Ivan Lazar Miljenovic, Ivan
Miljenovic, J. Pablo Fernández, J.A. Zaratiegui, Jaap Weel,
Jacques Richer, Jake McArthur, Jake Poznanski, Jakub Kotowski,
Jakub Labath, James Cunningham, James Smith, Jamie Brandon, Jan
Sabbe, Jared Roberts, Jason Dusek, Jason F, Jason Kikel, Jason
Mobarak, Jason Morton, Jason Rogers, Jeff Balogh, Jeff Caldwell,
Jeff Petkau, Jeffrey Bolden, Jeremy Crosbie, Jeremy Fitzhardinge,
Jeremy O'Donoghue, Jeroen Pulles, Jim Apple, Jim Crayne, Jim Snow,
Joan Jiménez, Joe Fredette, Joe Healy, Joel Lathrop, Joeri Samson,
Johannes Laire, John Cowan, John Doe, John Hamilton, John
Hornbeck, John Lien, John Stracke, Jonathan Guitton, Joseph Bruce,
Joseph H. Buehler, Josh Goldfoot, Josh Lee, Josh Stone, Judah
Jacobson, Justin George, Justin Goguen, Kamal Al-Marhubi, Kamil
Dworakowski, Keegan Carruthers-Smith, Keith Fahlgren, Keith
Willoughby, Ken Allen, Ken Shirriff, Kent Hunter, Kevin Hely,
Kevin Scaldeferri, Kingdon Barrett, Kristjan Kannike, Kurt Jung,
Lanny Ripple, Laurențiu Nicola, Laurie Cheers, Lennart Kolmodin,
Liam Groener, Lin Sun, Lionel Barret de Nazaris, Loup Vaillant,
Luke Plant, Lutz Donnerhacke, Maarten Hazewinkel, Malcolm
Reynolds, Marco Piccioni, Mark Hahnenberg, Mark Woodward, Marko
Tosic, Markus Schnell, Martijn van Egdom, Martin Bayer, Martin
DeMello, Martin Dybdal, Martin Geisler, Martin Grabmueller, Matúš
Tejiščák, Mathew Manela, Matt Brandt, Matt Russell, Matt Trinneer,
Matti Niemenmaa, Matti Nykänen, Max Cantor, Maxime Henrion,
Michael Albert, Michael Brauwerman, Michael Campbell, Michael
Chermside, Michael Cook, Michael Dougherty, Michael Feathers,
Michael Grinder, Michael Kagalenko, Michael Kaplan, Michael
Orlitzky, Michael Smith, Michael Stone, Michael Walter, Michel
Salim, Mikael Vejdemo Johansson, Mike Coleman, Mike Depot, Mike
Tremoulet, Mike Vanier, Mirko Rahn, Miron Brezuleanu, Morten
Andersen, Nathan Bronson, Nathan Stien, Naveen Nathan, Neil
Bartlett, Neil Whitaker, Nick Gibson, Nick Messenger, Nick
Okasinski, Nicola Paolucci, Nicolas Frisby, Niels Aan de Brugh,
Niels Holmgaard Andersen, Nima Negahban, Olaf Leidinger, Oleg
Anashkin, Oleg Dopertchouk, Oleg Taykalo, Oliver Charles, Olivier
Boudry, Omar Antolín Camarena, Parnell Flynn, Patrick Carlisle,
Paul Brown, Paul Delhanty, Paul Johnson, Paul Lotti, Paul Moore,
Paul Stanley, Paulo Tanimoto, Per Vognsen, Pete Kazmier, Peter
Aarestad, Peter Ipacs, Peter Kovaliov, Peter Merel, Peter Seibel,
Peter Sumskas, Phil Armstrong, Philip Armstrong, Philip Craig,
Philip Neustrom, Philip Turnbull, Piers Harding, Piet Delport,
Pragya Agarwal, Raúl Gutiérrez, Rafael Alemida, Rajesh Krishnan,
Ralph Glass, Rauli Ruohonen, Ravi Nanavati, Raymond Pasco, Reid
Barton, Reto Kramer, Reza Ziaei, Rhys Ulerich, Ricardo Herrmann,
Richard Harris, Richard Warburton, Rick van Hattem, Rob Grainger,
Robbie Kop, Rogan Creswick, Roman Gonzalez, Rory Winston, Ruediger
Hanke, Rusty Mellinger, Ryan Grant, Ryan Ingram, Ryan Janzen, Ryan
Kaulakis, Ryan Stutsman, Ryan T. Mulligan, S Pai, Sam Lee, Sandy
Nicholson, Scott Brickner, Scott Rankin, Scott Ribe, Sean Cross,
Sean Leather, Sergei Trofimovich, Sergio Urinovsky, Seth Gordon,
Seth Tisue, Shawn Boyette, Simon Brenner, Simon Farnsworth, Simon
Marlow, Simon Meier, Simon Morgan, Sriram Srinivasan, Sriram
Srinivasan, Stefan Aeschbacher, Stefan Muenzel, Stephan
Friedrichs, Stephan Nies, Stephan-A. Posselt, Stephyn Butcher,
Steven Ashley, Stuart Dootson, Terry Michaels, Thomas Cellerier,
Thomas Fuhrmann, Thomas Hunger, Thomas M. DuBuisson, Thomas
Moertel, Thomas Schilling, Thorsten Seitz, Tibor Simic, Tilo
Wiklund, Tim Clark, Tim Eves, Tim Massingham, Tim Rakowski, Tim
Wiess, Timo B. Hübel, Timothy Fitz, Tom Moertel, Tomáš Janoušek,
Tony Colston, Travis B. Hartwell, Tristan Allwood, Tristan
Seligmann, Tristram Brelstaff, Vesa Kaihlavirta, Victor Nazarov,
Ville Aine, Vincent Foley, Vipul Ved Prakash, Vlad Skvortsov,
Vojtěch Fried, Wei Cheng, Wei Hu, Will Barrett, Will Farr, Will
Leinweber, Will Robertson, Will Thompson, Wirt Wolff, Wolfgang
Jeltsch, Yuval Kogman, Zach Kozatek, Zachary Smestad, Zohar
Kelrich.

Sau cùng, chúng tôi muốn cảm ơn những độc giả, những người đã gửi 
hơn 800 ý kiến khuyết danh.
